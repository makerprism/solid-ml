# A-06: SolidJS-style Template Compiler Plan (MLX + PPX)

**Status:** Plan complete (updated Jan 2026; ready to implement)

This document describes a **SolidJS-style template compilation** system for solid-ml, with:

- **Primary authoring API:** MLX (JSX-like syntax)
- **Compilation:** a PPX that lowers MLX output into `Html.Template` instantiation + bindings
- **Runtime target:** a small backend interface implemented by both SSR and browser Html backends
- **Hydration strategy:** **path-based hydration** (no selector queries; no user-authored IDs), with **compile-time template normalization** to make paths stable

The goal is to make shared components (SSR + browser) feel like SolidJS: static template instantiation + fine-grained bindings.

---

## 0. Current State (already implemented)

This repo already contains foundational work for the template direction:

- `solid-ml-template-runtime` (shared module types)
  - Signature: `lib/solid-ml-template-runtime/solid_ml_template_runtime.ml`
- `solid-ml-template-ppx` (PPX implementation)
  - Implementation: `lib/solid-ml-template-ppx/solid_ml_template_ppx.ml`
- `Html_intf.S` requires a `Template` submodule
  - Interface: `lib/solid-ml/html_intf.ml`
- SSR and Browser Html implement `Template`
  - SSR: `lib/solid-ml-ssr/html.ml`
  - Browser: `lib/solid-ml-browser/html.ml`
- A basic SSR test exists: `test/test_template.ml`

These pieces validate the core direction: compiled output can target a backend-neutral `Html.Template` surface.

**Important missing prerequisites (tracked in milestones below):**

- A shared **reactivity surface** for compiled bindings (effects + cleanup), not just signals
- MLX integration + a clear contract for the post-MLX AST shapes the template PPX will consume
- A `Tpl` marker module (and a deliberate failure mode when the template PPX is not enabled)

---

## 1. Goals / Non-Goals

### Goals

1. **SolidJS-style performance model**
   - SSR: render via `segments + holes` (string concatenation)
   - Browser: instantiate a static DOM template, then attach bindings

2. **Primary DX: MLX-first**
   - Most components should be authored as MLX templates, not manual `Html.div` calls

3. **Shared components**
   - The same component source compiles to SSR and browser builds

4. **Path-based hydration**
   - Bindings locate nodes by deterministic DOM paths generated by the compiler

5. **Explicit, compiler-recognizable syntax for dynamics**
   - No type-driven inference required (PPX has no types)
   - Syntax must be compatible with OCaml identifiers

### Non-Goals (initially)

- Streaming SSR and event replay
- Full parity with SolidJS compiler optimizations
- Automatically inferring which props are reactive without explicit wrappers
- Supporting every HTML edge-case from day 1 (e.g. rare parsing quirks)

---

## 2. Design Decisions (resolved)

This section converts “open questions” into explicit decisions so the plan is executable.

### 2.1 Template roots (hydration constraint)

`Solid_ml_template_runtime.TEMPLATE.hydrate` currently takes `root:element`.

**Decision (v1): compiled templates must have exactly one root element.**

- The template PPX errors if the template root is a fragment with multiple top-level nodes.
- A future v2 can relax this by extending `hydrate` to accept a `node` (or a fragment root).

**Additional decision (v1): the template instance “root” for path purposes is the template root element.**

- This is required for stable paths between CSR (`instantiate`) and hydration (`hydrate`).
- Concretely, the browser `Template.instantiate` implementation should expose the single root element as the instance root (not a wrapper fragment) when used by compiled templates.

### 2.2 What is a “path”?

A **path** is an `int array` of `childNodes` indices **from the template root element**.

- Paths are interpreted using DOM `childNodes` ordering (elements + text nodes).
- Paths assume **template normalization** removes whitespace-only text nodes that are purely formatting.

There are two path shapes in the runtime interface:

- **Element path** (used by `bind_element`): locates an existing element node.
- **Insertion path** (used by `bind_text`): all but the last index locate the parent node; the last index is the child insertion index for the (possibly compiler-created) text node.

### 2.3 How reactivity is expressed in source (no types needed)

The PPX cannot inspect types, so the authoring surface must mark dynamic expressions explicitly.

**Decision (v1): dynamic values are passed as thunks** so they can read any signals inside.

- Example: `{Tpl.text (fun () -> Int.to_string (Signal.get count))}`
- The compiler generates an `Effect` that re-runs this thunk when the signals it reads change.

This matches SolidJS ergonomics (dynamic expressions can reference multiple signals).

### 2.4 Binding responsibilities (SSR vs browser)

- **SSR:** slots are filled by string interpolation using `slot_kinds` to escape correctly.
- **Browser (CSR/hydration):** bindings locate nodes by path and set properties/attrs/text.

**Decision:** attribute dynamics are expressed via `bind_element + set_attr` rather than a dedicated “attr slot” handle.

- Browser sets attributes via DOM APIs; for CSR, attribute slots can be emitted as an empty string placeholder (e.g. `href=""`), and bindings set/remove the real value after instantiation.
- SSR uses `Template.bind_element` to obtain an element handle and `Template.set_attr` to inject attributes into the rendered HTML. In the SSR backend this is implemented by recording attributes per element path and injecting them into the corresponding opening tag during `Template.root` rendering.

### 2.5 Markers in compiled templates

**Decision (v1):** compiled templates may inject *template-internal* HTML comment markers to stabilize DOM shape for `Tpl.text`.

- Compiled templates still do **not** use the hydration-key markers (`<!--hk:...-->`) used by `Html.reactive_text`.
- Instead, the template compiler can emit stable comment placeholders (SolidJS-style, e.g. `<!--#-->`) around text-slot boundaries.
- This prevents adjacent static text from being merged by HTML parsing, and ensures `bind_text` insertion paths remain stable for both CSR and hydration.

### 2.6 What happens if the template PPX can’t compile something?

The template compiler is opt-in, but `Tpl.*` markers must never reach runtime.

**Decision (v1): compilation is “all-or-nothing” per JSX tree.**

- If a JSX tree contains **no** `Tpl.*` markers, the PPX is allowed to leave it as the plain MLX expansion.
- If a JSX tree contains **any** `Tpl.*` marker and the PPX cannot compile it, the PPX errors with a clear message.

Rationale: this prevents “half-compiled” trees where some dynamics silently fall back to non-template behavior.

---

## 3. Required Shared Reactivity Surface (for compiled bindings)

Compiled bindings need:

- `Effect.create` (to update DOM when signal dependencies change)
- `Owner.on_cleanup` (to dispose event listeners / nested mounts in conditionals/lists)
- optionally `Effect.untrack` (to avoid accidental tracking in some binding helpers)

### Proposed change

Extend `Solid_ml.Component.COMPONENT_ENV` (defined in `lib/solid-ml/component.ml`) or add a sibling module type used only by the compiler to include:

- `module Effect : sig val create : (unit -> unit) -> unit ... end`
- `module Owner : sig val on_cleanup : (unit -> unit) -> unit ... end`

Server env can re-export `Solid_ml.Effect` / `Solid_ml.Owner`.
Browser env can re-export `Solid_ml_browser.Reactive.Effect` / `Solid_ml_browser.Reactive.Owner`.

**Rationale:** without this, the compiler cannot generate shared code that attaches fine-grained reactive bindings.

---

## 4. High-Level Architecture

### 4.1 Pipeline

1. Author writes MLX in `.ml` files.
2. MLX PPX lowers JSX into OCaml calls.
3. `solid-ml-template-ppx` runs **after MLX** and:
   - detects “JSX-shaped” AST for supported constructs
   - builds a Template IR
   - emits:
      - a static `Html.Template.compile ~segments ~slot_kinds` value
      - an instantiation function that:
        - instantiates/hydrates the template
        - binds nodes (by path)
        - attaches reactive bindings via `Env.Effect.create`
        - returns `Html.Template.root`

Likely files:

- `lib/solid-ml-template-ppx/solid_ml_template_ppx.ml` (actual implementation)
- `test/test_template.ml` and new integration tests (SSR + browser)
- `test_browser/` (hydration + reactive update assertions)

**Tests (must pass)**

- `dune build`
- `dune runtest`

**Example**

- See `examples/template_counter/` (Milestone 4).

### Milestone 1: Formalize Template runtime v1

**Status:** partially done (interface exists, SSR + browser implementations exist)

**Work**

- Freeze `Solid_ml_template_runtime.TEMPLATE` signature as v1.
- Add explicit documentation comments on path semantics:
  - root element constraint
  - element paths vs insertion paths
- Align browser instance root semantics for stable paths:
  - `Template.instantiate` exposes the single root element as the instance root
  - compiler-emitted paths are relative to that root element (matching hydration)
- Provide a small helper in browser `Template` to compute `node_at` deterministically (already present as `node_at`).

Likely files:

- `lib/solid-ml-template-runtime/solid_ml_template_runtime.ml` (docs; path semantics)
- `lib/solid-ml-ssr/html.ml` and `lib/solid-ml-browser/html.ml` (backend notes/validation)
- `test/test_template.ml` (extend coverage)

**Tests (must pass)**

- `dune build`
- `dune runtest`
- Extend `test/test_template.ml` with:
  - multiple slots
  - mixed `\`Text` and `\`Attr`
  - escaping behavior (already partly covered)

**Example**

- Extend `test/test_template.ml` with a multi-slot template, e.g.:
  - `segments = [| "<div>"; "</div><a href=\""; "\">x</a>" |]`
  - `slot_kinds = [| `Text; `Attr |]`

### Milestone 2: Template normalization (compile-time)

**Work**

- Implement compiler-side template normalization:
  - eliminate whitespace-only formatting text nodes between elements
  - canonicalize void element printing
  - emit stable attribute quoting

Likely files:

- `lib/solid-ml-template-ppx/` (new normalization + HTML emission helpers)
- `test/` (normalization-focused compiler/ppx tests)

**Tests (must pass)**

- Add normalization-focused tests in the PPX package:
  - the same template with different source formatting yields identical `segments` output
- Add a semantic SSR test:
  - compiled template renders identically regardless of formatting

Commands:

- `dune build`
- `dune runtest`

**Example**

- Two MLX templates that differ only by whitespace/newlines (between children) compile to identical `segments` and identical slot paths.

### Milestone 3: Browser Template hydration validation

**Work**

- Strengthen browser `Template.hydrate` semantics:
  - validate that the hydrated `root` matches the template root tag (best-effort)
  - ensure `bind_text` insertion paths work for both CSR and hydration

Likely files:

- `lib/solid-ml-browser/html.ml` (`Template.hydrate`, `bind_text`, optional validation)
- `test_browser/` (DOM-based hydration tests)

**Tests (must pass)**

- Add browser tests under `test_browser/` that:
  - render SSR HTML string into a DOM root
  - run `Template.hydrate`
  - bind a text slot via an insertion path
  - update the slot and assert DOM updates

Commands:

- `dune runtest`
- `make browser-tests`

**Example**

- Given `<div>{slot}</div>`, the compiler should emit `bind_text ~path:[|0|]` (insert text at child index 0 of the root element), and hydration should update that node without querying selectors.

### Milestone 4: PPX — compile a minimal template (intrinsics + Tpl.text)

**Update (Jan 2026):** the PPX now supports nested intrinsic tags (not just flat children lists), and can bind `Tpl.attr`/`Tpl.attr_opt` on nested elements by computing element paths.

**Work**

- In `solid-ml-template-ppx`:
  - detect JSX-shaped AST for a subset:
    - intrinsic HTML/SVG tags only (i.e. calls to the `Html_intf.S` element functions)
    - static elements
    - static attributes
    - static text
    - `Tpl.text` dynamic text slots
  - emit:
    - `let template = Html.Template.compile ...`
    - `let inst = Html.Template.instantiate template` (CSR) or `Html.Template.hydrate ~root template` (hydration)
    - `let slot = Html.Template.bind_text inst ~id ~path`
    - `Env.Effect.create (fun () -> Html.Template.set_text slot (thunk ()))`

**Tests (must pass)**

- Semantic integration tests (required):
  - compile a tiny MLX component with the PPX enabled
  - execute it in SSR mode and assert exact HTML output
  - execute it in browser test mode, hydrate it, and assert DOM updates when signals change

Commands:

- `dune build`
- `dune runtest`

**Example**

- Add `examples/template_counter/`:
  - shared MLX component using `Tpl.text`
  - server renders it
  - browser hydrates it

### Milestone 5: Dedicated syntax for attributes + classList

**Work**

- Add `Tpl.attr`, `Tpl.attr_opt`, `Tpl.class_list`, and `Tpl.on` wrappers.
- Extend PPX to:
  - turn `Tpl.attr` / `Tpl.attr_opt` thunks into:
    - `bind_element` for the target element
    - `Effect.create` that calls `set_attr` (removing the attribute when `None`)
  - turn event bindings into:
    - `bind_element` for the target element
    - `Template.on_ ~event:(...) handler` (SSR is a no-op)

Likely files:

- `lib/solid-ml-template-runtime/` (add/expand `Tpl` markers)
- `lib/solid-ml-template-ppx/` (emit `set_attr`, `on_`, `classList` bindings)
- `test/` and `test_browser/` (attrs, class, events)

**Tests (must pass)**

- SSR tests:
  - generated HTML matches expected attributes/classes
- Browser tests:
  - signal updates reflect on DOM attributes/classes

Commands:

- `dune runtest`
- `make browser-tests`

**Example**

- Extend `examples/template_counter/` with reactive class and reactive `href`.

### Milestone 6: Conditionals and lists

**Work**

- Add template-level control-flow constructs:
  - `Tpl.show ~when_:(unit -> bool) (fun () -> <...>)`
  - `Tpl.each_keyed ~items:(unit -> 'a list) ~key ~render`
- PPX rewrites these into specialized runtime calls.

**Tests (must pass)**

- SSR tests:
  - conditional renders correct branch
  - list renders correct markup
- Browser tests:
  - toggling `when_` mounts/unmounts
  - list updates preserve keyed nodes

Commands:

- `dune runtest`
- `make browser-tests`

**Example**

- Add `examples/template_todo/` or refactor `examples/todo/` to compiled templates.

### Milestone 7: Make compiled templates the default (primary API)

**Work**

- Update docs/examples to use MLX + template compiler.
- Add repository guidance encouraging template compilation for most components.

**Tests (must pass)**

- `dune build`
- `dune runtest`
- `make browser-tests`
- Example build targets succeed:
  - `make browser-examples`

---

## 5. Authoring Surface (`Tpl` markers + MLX)

The template compiler needs explicit, PPX-recognizable markers for dynamics. These should be:

- usable from MLX (JSX-style `{...}` expressions and `attr={...}`)
- typecheckable without requiring the compiler to see types
- guaranteed not to silently run at runtime if the template PPX is not enabled

### 5.1 `Tpl` marker module

Create a `Tpl` module (in `solid-ml-template-runtime`) that is only a **marker surface** for the PPX.

Proposed API (v1):

- `type 'a Tpl.t` (marker type)
- `Tpl.text : (unit -> string) -> 'a Tpl.t`
- `Tpl.attr : name:string -> (unit -> string) -> 'a Tpl.t`
- `Tpl.attr_opt : name:string -> (unit -> string option) -> 'a Tpl.t`
- `Tpl.class_list : (unit -> (string * bool) list) -> 'a Tpl.t`
- `Tpl.on : event:string -> ('ev -> unit) -> ('ev -> unit) Tpl.t`
- `Tpl.show : when_:(unit -> bool) -> (unit -> 'a) -> 'a Tpl.t`
- `Tpl.each_keyed : items:(unit -> 'a list) -> key:('a -> string) -> render:('a -> 'b) -> 'b Tpl.t`

Notes:

- The concrete return types are intentionally left abstract here: the PPX rewrites them away.
- The event handler argument type is intentionally polymorphic (`'ev`); the PPX emits the backend-specific event type in the rewritten code.
- The PPX should be able to find these markers by their fully-qualified path (e.g. `Solid_ml_template_runtime.Tpl.text`) to avoid accidental shadowing.

### 5.2 Deliberate failure mode ("best of both worlds")

The goal is to avoid the footgun where `Tpl.*` reaches runtime.

Decision (v1): use a **marker-type** design in the runtime library, and **PPX error reporting** for unsupported constructs.

1. **Marker-type design (works without PPX plumbing in the runtime library)**

   `solid-ml-template-runtime` defines `type 'a Tpl.t` and all `Tpl.*` helpers return this marker type.

   - Without the template compiler, any attempt to use a `Tpl.*` marker as a node/attr/handler produces a type error mentioning `Solid_ml_template_runtime.Tpl.t`.
   - This keeps `solid-ml-template-runtime` free of PPX dependencies and works in byte/native/melange.

2. **PPX-driven errors (more helpful than raw type errors)**

   When `solid-ml-template-ppx` is enabled, it should detect `Tpl.*` markers and:

   - either fully compile the containing MLX tree into `Html.Template.*` calls, or
   - raise a compiler error with:
     - the unsupported construct
     - the location
     - a hint about the currently supported subset
     - a fix hint (ensure `.mlx` support is enabled and `solid-ml-template-ppx` is in `(pps ...)`)

This approach gives the early-failure guarantee of the extension-node idea, without forcing PPX usage inside the shared runtime package.

### 5.3 Minimal authoring examples

Dynamic text:

```ocaml
<div>
  (Tpl.text (fun () -> string_of_int (Signal.get count)))
</div>
```

Dynamic attribute:

```ocaml
<a href=(Tpl.attr ~name:"href" (fun () -> url ()))>
  "link"
</a>
```

Event handler:

```ocaml
<button onclick=(Tpl.on ~event:"click" (fun _ev -> incr ()))>
  "inc"
</button>
```

(Exact attribute names depend on MLX’s attribute-to-OCaml mapping; the PPX only needs the post-MLX AST shape.)

### 5.4 Enabling the compiler

MLX syntax is supported via a **dune dialect** (MLX is a syntax preprocessor, not a PPX library).

In your `dune-project`:

```lisp
(dialect
 (name mlx)
 (implementation
  (extension mlx)
  (preprocess
   (run mlx-pp %{input-file}))))
```

Then, in `dune` stanzas that use templates:

- Enable the template compiler PPX:
  - `(preprocess (pps solid-ml-template-ppx))`

Notes:

- If you also use other PPX rewriters, keep `solid-ml-template-ppx` in the same `(pps ...)` list.
- For editor support, MLX recommends installing `ocamlmerlin-mlx`.

---

## 6. Template IR, Normalization, and Slot/Path Generation

### 6.1 Template IR (compiler-internal)

The PPX should lower JSX-shaped AST into a small IR before emitting runtime code.

Minimal IR (v1):

- `Element { tag : string; attrs : attr list; children : node list }`
- `Text of string`
- `Text_slot of { id : int; insertion_path : int array }`
- (later) `Attr_binding`, `Event_binding`, `Show`, `Each_keyed`

### 6.2 Slot generation

- Slots are assigned ids in a stable traversal order (depth-first, left-to-right) over the **normalized** IR.
- Each slot also records its kind (`Text` vs `Attr`) for SSR escaping via `slot_kinds`.

### 6.3 Path generation

Paths must be stable across SSR → hydration.

Decision (v1): compiler-emitted paths are always relative to the template’s single root element.

- For `bind_element`: the path locates the element node.
- For `bind_text`: the path is an insertion path as described in `Solid_ml_template_runtime.TEMPLATE.bind_text`.

Implementation note:

- The current browser `Template.instantiate` returns a fragment root. To make paths stable, the browser backend should expose the *single* root element as the instance root when the template has exactly one root element.

### 6.4 Normalization rules (v1)

Normalization is what makes paths deterministic even if the author formats MLX across lines.

- Remove whitespace-only text nodes that exist only for formatting between element children.
- Preserve meaningful whitespace inside text nodes (e.g. "hello world").
- Canonicalize void elements to a consistent serialization.
- Canonicalize attribute quoting (always double quotes in `segments`).

---

## 7. PPX Implementation Plan (post-MLX)

### 7.1 Matching strategy

The `solid-ml-template-ppx` runs after MLX and looks for the (post-MLX) AST patterns that represent HTML element construction.

Decision (v1): support a narrow, explicit subset first:

- intrinsic tags backed by `Html_intf.S` element functions
- static text + static attributes
- dynamic text via `Tpl.text`

### 7.2 Error handling

- If an MLX tree contains any `Tpl.*` marker and the PPX cannot compile the tree, error with:
  - the unsupported construct
  - the location
  - a hint for the supported subset
  - a fix hint (ensure `.mlx` support is enabled and `solid-ml-template-ppx` is in `(pps ...)`)

Note: even without PPX errors, the marker-type design ensures `Tpl.*` cannot be silently used as a normal node/attr/event value.

### 7.3 Code generation shape

For each compiled template expression, emit (conceptually):

- a `template` constant:
  - `let template = Html.Template.compile ~segments ~slot_kinds`
- an instantiation path:
  - CSR: `let inst = Html.Template.instantiate template`
  - Hydration: `let inst = Html.Template.hydrate ~root template`
- bindings:
  - `let slot = Html.Template.bind_text inst ~id ~path`
  - `Env.Effect.create (fun () -> Html.Template.set_text slot (thunk ()))`
- final value:
  - `Html.Template.root inst`

The PPX should generate hygienic names (e.g. `__solid_template_1`, `__solid_slot_1`) to avoid clashes.

---

## 8. Integration, Packaging, and Tests

### 8.1 Package layout

- `solid-ml-template-runtime`:
  - `Solid_ml_template_runtime.TEMPLATE` (already exists)
  - `Solid_ml_template_runtime.Tpl` marker module (marker-type design)
- `solid-ml-template-ppx`:
  - PPX that rewrites MLX output into `Html.Template.*` calls

### 8.2 Build integration tests

Add integration tests that ensure the PPX actually runs and the compiled output behaves correctly:

- SSR: compile a tiny MLX component with `Tpl.text` and assert exact output HTML.
- Browser: instantiate or hydrate and assert DOM updates after signal changes.

This should live alongside existing tests:

- `test/test_template.ml`
- `test_browser/test_reactive.ml` (and new template-focused browser tests)

---

## 9. Acceptance Criteria (global)

A release candidate for the system must satisfy:

- Works with shared components compiled for SSR + browser.
- Browser hydration works using **paths** (no query selectors and no forced IDs).
- Generated SSR HTML is close to designer HTML (no mandatory internal marker attributes).
- All tests pass:
  - `dune build`
  - `dune runtest`
  - `make browser-tests`
- At least one end-to-end example demonstrating:
  - SSR render
  - hydration
  - reactive updates
  - event handler binding

---

## 10. Notes (remaining intentionally)

- A future version can add deeper compiler optimizations (hoisting, partial eval, etc.), but correctness and stable hydration paths are the primary v1 objectives.
- If MLX output patterns are too unstable to match reliably, a fallback is to introduce a small “intrinsics layer” that MLX expands into (so the template PPX matches stable intrinsics, not MLX internals).
