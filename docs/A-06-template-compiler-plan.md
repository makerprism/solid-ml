# A-06: SolidJS-style Template Compiler Plan (MLX + PPX)

**Status:** Implementation plan (living document)

This document describes a **SolidJS-style template compilation** system for solid-ml, with:

- **Primary authoring API:** MLX (JSX-like syntax)
- **Compilation:** a PPX that lowers MLX output into `Html.Template` instantiation + bindings
- **Runtime target:** a small backend interface implemented by both SSR and browser Html backends
- **Hydration strategy:** **path-based hydration** (no selector queries; no user-authored IDs), with **compile-time template normalization** to make paths stable

The goal is to make shared components (SSR + browser) feel like SolidJS: static template cloning + fine-grained bindings.

---

## 0. Current State (already implemented)

This repo now contains foundational work:

- `solid-ml-template-runtime` (shared module types) under `lib/solid-ml-template-runtime/`
- `solid-ml-template-ppx` (PPX stub) under `lib/solid-ml-template-ppx/`
- `Html_intf.S` has a new required `Template` submodule
- SSR and Browser Html implement `Template`
- A basic SSR test exists: `test/test_template.ml`

These pieces validate the core direction: compiled output can target a backend-neutral `Html.Template` surface.

---

## 1. Goals / Non-Goals

### Goals

1. **SolidJS-style performance model**
   - SSR: render via `segments + holes` (string concatenation, not building large node trees)
   - Browser: clone a static DOM template, then attach bindings

2. **Primary DX: MLX-first**
   - Most components should be authored as MLX templates, not manual `Html.div` calls

3. **Shared components**
   - The same component source compiles to SSR and browser builds

4. **Path-based hydration**
   - Bindings locate nodes by deterministic DOM paths generated by the compiler

5. **Dedicated syntax for reactivity and dynamic attributes**
   - Similar to SolidJS conventions (e.g. `classList`, `attr:`), adapted to OCaml constraints

### Non-Goals (initially)

- Streaming SSR and event replay
- Full parity with SolidJS compiler optimizations
- Automatically inferring which props are reactive without explicit wrappers

---

## 2. High-Level Architecture

### Pipeline

1. Author writes MLX in `.ml` files.
2. MLX PPX lowers JSX into OCaml calls (annotated with `[@JSX]`).
3. `solid-ml-template-ppx` runs **after MLX** and:
   - detects JSX-shaped AST
   - builds a **Template IR**
   - emits:
     - a static `Html.Template.compile ~segments ~slot_kinds` value
     - an instantiation function:
       - clones/instantiates
       - binds nodes (by path)
       - sets up reactive bindings (effects)
       - returns `Html.Template.root`

### Runtime Target

The compiler targets `Env.Html.Template` (a `Solid_ml_template_runtime.TEMPLATE`) which is implemented by:

- `Solid_ml_ssr.Html.Template`
- `Solid_ml_browser.Html.Template`

The compiled code must be valid under `Solid_ml.Component.COMPONENT_ENV`.

---

## 3. Template IR (compiler internal)

### Core representation

The compiler produces:

- `segments : string array`
  - static HTML segments
  - invariant: `len(segments) = len(slot_kinds) + 1`

- `slot_kinds : slot_kind array`
  - `\`Text` and `\`Attr`
  - note: this is primarily an SSR rendering concern (string interpolation)

- `bindings : binding list`
  - binding instructions targeting nodes/elements by **path**
  - bindings cover dynamic attributes/classes/styles/events/lists/conditionals

### Path-based node addressing

- A **path** is an `int array` of child indices starting from the template instance root.
- Paths are interpreted using DOM `childNodes` ordering.
- **Template normalization requirement:** the compiler must emit a canonical HTML string such that:
  - there are no "insignificant" whitespace-only text nodes between elements
  - attribute ordering/quoting is stable
  - no internal comment markers are required for compiled templates

This is what makes child-index paths stable across SSR output, browser parsing, and hydration.

### Text slot addressing (insertion paths)

Dynamic text is represented as a **slot** and is located by an *insertion path*:

- All but the last index locate the parent node
- The last index is the insertion position of the text node under that parent

The browser runtime must create the text node if it does not exist at hydration/CSR time.

### Binding types (initial set)

1. Text binding
   - updates a text node’s content

2. Attribute binding
   - sets/removes attribute values

3. Event handler binding
   - attaches DOM listeners (no-op on SSR)

4. `classList` / class toggle binding

5. `style` binding

6. Conditional blocks (`<Show>`-like)
   - compiled to a mount/unmount region
   - must register cleanup so effects/listeners are disposed when unmounted

7. List blocks (`<For>` / keyed loop)
   - compiled to a keyed reconciler
   - must not leak listeners/effects when items are removed/replaced

---

## 4. Dedicated Syntax (authoring surface)

Because OCaml identifiers cannot contain `:` or `-`, SolidJS-style syntax like `attr:href` needs a different spelling.

### Recommended approach: explicit wrapper functions

Introduce a small DSL module that is **only used for typing** and PPX recognition.
The PPX rewrites these wrappers into template slots and bindings.

Example proposals:

- Text:
  - `{Tpl.text count}` where `count : int Signal.t`
  - `{Tpl.text_of fmt signal}`

- Attributes:
  - `href=(Tpl.attr href_signal)`
  - `aria_label=(Tpl.attr_opt aria_label_signal)`

- classList:
  - `class_=(Tpl.class_list [ ("active", is_active); ("disabled", is_disabled) ])`

- style:
  - `style=(Tpl.style [ ("opacity", opacity_signal) ])`

- events:
  - `onclick=(Tpl.on_click handler)` (or directly `onclick=handler` and PPX treats it as event binding)

The DSL should live in a package that is available to both SSR and browser compilation (likely `solid-ml-template-runtime` or a new `solid-ml-template` helper lib).

**Acceptance:** the final syntax should be close enough to HTML that diffs vs designer templates are small.

---

## 5. Runtime Requirements for “Real SolidJS-style”

### Key requirements

1. **No internal hydration markers in compiled templates**
   - Compiled templates must not inject `<!--hk:...-->` comments.
   - SSR output should remain close to designer HTML.

2. **SSR rendering via string interpolation**
   - `\`Text` slots interpolate escaped text directly
   - `\`Attr` slots interpolate escaped attribute contents

3. **Browser instantiation via template cloning**
   - The browser runtime must be able to instantiate a template efficiently.
   - An initial implementation can build a container via `innerHTML` and clone it.
   - A later optimization can use `HTMLTemplateElement` semantics.

4. **Hydration via adoption**
   - The runtime must support `Template.hydrate` as part of the base interface.
   - Hydration adopts existing DOM starting from a known root element and binds via normalized paths.

5. **Text slot insertion**
   - The browser runtime must be able to create/insert missing text nodes at a specific insertion index under a parent node.

---

## 6. Milestones (very detailed)

Each milestone lists required code changes, tests that must pass, and an example/demo requirement.

### Milestone 1: Formalize Template runtime v1

**Work**
- Freeze `Solid_ml_template_runtime.TEMPLATE` signature as v1.
- Add explicit documentation comments on path semantics.
- Provide a small helper function in browser Template to compute `node_at` deterministically.

**Tests (must pass)**
- `dune build`
- `dune runtest`
- Extend `test/test_template.ml` with:
  - multiple slots
  - mixed `\`Text` and `\`Attr`
  - escaping behavior (already partly covered)

**Example**
- None (runtime-only milestone).

### Milestone 2: Template normalization (compile-time)

**Work**
- Implement compiler-side **template normalization**:
  - strip whitespace-only text nodes between elements
  - normalize attribute ordering and quoting
  - produce a canonical HTML string used for both SSR and browser instantiation

**Tests (must pass)**
- Add normalization tests in the PPX package:
  - given a template with various formatting/whitespace, normalization produces an identical canonical string
- Add a semantic SSR test:
  - a compiled template renders identically regardless of source formatting

Commands:
- `dune build`
- `dune runtest`

**Example**
- None (compiler-only milestone).

### Milestone 3: Browser Template hydration (adopt existing DOM)

**Work**
- Implement `Template.hydrate` in the browser backend (it is part of the base interface).
- Ensure `bind_text` uses insertion paths and creates missing text nodes.

**Tests (must pass)**
- Add browser tests under `test_browser/` that:
  - render SSR HTML string into a DOM root
  - run `Template.hydrate`
  - bind a text slot via an insertion path
  - update the slot and assert DOM updates

Commands:
- `dune runtest`
- `make browser-tests`

**Example**
- Update an existing hydration example (e.g. `examples/full_ssr_app/`) to hydrate a compiled template component.


### Milestone 4: PPX — compile a minimal template

**Work**
- In `solid-ml-template-ppx`:
  - detect JSX-shaped AST for a subset:
    - static elements
    - static attributes
    - static text
    - `Tpl.text` dynamic text slots
  - emit:
    - `let template = Html.Template.compile ...`
    - `let inst = Html.Template.instantiate template`
    - `let slot = Html.Template.bind_text inst ~id ~path`
    - `Html.Template.set_text slot (string_of_int (Signal.get ...))` via an effect in browser

**Tests (must pass)**
- Semantic integration tests (required):
  - compile a tiny MLX component with the PPX enabled
  - execute it in SSR mode and assert exact HTML output
  - execute it in browser test mode, hydrate it, and assert DOM updates on signal changes
- Optional PPX-level tests:
  - (secondary) snapshot the generated code for a couple of fixtures, but do not rely on this as the primary correctness signal

Commands:
- `dune build`
- `dune runtest`

**Example**
- Add `examples/template_counter/`:
  - shared MLX component using `Tpl.text`
  - server renders it
  - browser hydrates it

### Milestone 5: Dedicated syntax for attributes + classList

**Work**
- Add `Tpl.attr`, `Tpl.attr_opt`, `Tpl.class_list` wrappers.
- Extend PPX to:
  - turn `Tpl.attr signal` into an `\`Attr` slot + bind_element + set_attr binding
  - turn `Tpl.class_list` into class toggle bindings

**Tests (must pass)**
- SSR tests:
  - generated HTML matches expected attributes and classes
- Browser tests:
  - signal updates reflect on DOM attributes/classes

Commands:
- `dune runtest`
- `make browser-tests`

**Example**
- Extend `examples/template_counter/` with reactive class and reactive `href`.

### Milestone 6: Conditionals and lists

**Work**
- Add template-level control-flow constructs:
  - `Tpl.show ~when_:(bool Signal.t) (fun () -> <...>)`
  - `Tpl.each_keyed ~items ~key ~render`
- PPX rewrites these into specialized runtime calls (may reuse `Solid_ml_browser.Reactive.show` / `each_keyed`).

**Tests (must pass)**
- SSR tests:
  - conditional renders correct branch
  - list renders correct markup
- Browser tests:
  - toggling `when_` mounts/unmounts
  - list updates preserve keyed nodes

Commands:
- `dune runtest`
- `make browser-tests`

**Example**
- Add `examples/template_todo/` or refactor existing `examples/todo/` to compiled templates.

### Milestone 7: Make compiled templates the default (primary API)

**Work**
- Update docs/examples to use MLX + template compiler.
- Add a CI check (or repository guidance) encouraging template compilation for most components.

**Tests (must pass)**
- `dune build`
- `dune runtest`
- `make browser-tests`
- Example build targets succeed:
  - `make browser-examples`

---

## 7. Acceptance Criteria (global)

A release candidate for the system must satisfy:

- Works with shared components compiled for SSR + browser.
- Browser hydration works using **paths** (no query selectors and no forced IDs).
- Generated SSR HTML is close to designer HTML (no mandatory internal marker attributes).
- All tests pass:
  - `dune build`
  - `dune runtest`
  - `make browser-tests`
- At least one end-to-end example demonstrating:
  - SSR render
  - hydration
  - reactive updates
  - event handler binding

---

## 8. Notes / Open Questions

1. **Path stability definition**
   - Compiled templates MUST NOT rely on internal comment markers.
   - Paths are interpreted over `childNodes` in a **normalized template DOM**, meaning the compiler is responsible for eliminating whitespace-only nodes between elements.

2. **Typing of template DSL wrappers**
   - Wrappers should be zero-cost after PPX rewriting.
   - The types must be usable from shared components.

3. **Performance envelope**
   - Browser instantiation via `innerHTML` is acceptable early, but a `<template>` + `cloneNode` path is preferable.

4. **Security**
   - SSR escaping rules must remain correct for all slot kinds.
   - Browser-side attribute setting must preserve existing attribute-name sanitization rules.
