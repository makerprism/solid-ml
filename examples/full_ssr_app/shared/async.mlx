(**
    Reactive State Management Demo

    This component demonstrates:
    - Reactive signals for state management
    - Loading states with Tpl.show_when
    - Error handling and user feedback
    - Two-way binding with Tpl.bind_input
    - Derived state computation

    NOTE: This is a SYNCHRONOUS SIMULATION of async patterns.
    In a real app, you would use actual async operations with
    Resources or async primitives for true data fetching.

    The demo simulates loading states to show how to handle
    different UI states (loading, success, error) reactively.
*)

module Make (Env : Solid_ml_template_runtime.Env_intf.TEMPLATE_ENV) = struct
  open Env
  open Env.Html
  module Tpl = Env.Tpl
  module Routes = Routes

  (** {1 Data Types} *)

  type user = {
    id: int;
    name: string;
    email: string;
    bio: string option;
  }

  type fetch_status =
    | Idle
    | Loading
    | Success of user
    | Error of string

  type step_item = {
    idx: int;
    title: string;
    step_class: string;
    status_class: string;
    status_text: string;
    step_number: string;
    is_complete: bool;
  }

  (** {1 Mock Data Fetcher}

      In a real app, this would make an HTTP request.
      For SSR compatibility, we simulate async behavior with reactive state.
  *)

  let mock_users = [
    { id = 1; name = "Alice Johnson"; email = "alice@example.com"; bio = Some "Frontend developer" };
    { id = 2; name = "Bob Smith"; email = "bob@example.com"; bio = Some "Backend engineer" };
    { id = 3; name = "Carol Williams"; email = "carol@example.com"; bio = Some "Full-stack developer" };
    { id = 4; name = "David Brown"; email = "david@example.com"; bio = None };
    { id = 5; name = "Eve Davis"; email = "eve@example.com"; bio = Some "DevOps engineer" };
  ]

  let fetch_user_by_id ~id =
    (* Simulate network delay and return result *)
    List.find_opt (fun u -> u.id = id) mock_users

  (** {1 Async Resource Component}

      Demonstrates reactive state management for simulated async data fetching
  *)

  type schedule = delay_ms:int -> (unit -> unit) -> unit

  let resource_demo ~schedule () =
    (* Reactive state signals *)
    let user_id, set_user_id = Signal.create 1 in
    let loading, set_loading = Signal.create false in
    let error_msg, set_error_msg = Signal.create (Some "") in

    (* Derived: Get current user based on user_id signal *)
    let current_user () =
      let id = Signal.get user_id in
      fetch_user_by_id ~id
    in

    (* Fetch next user with simulated loading state *)
    let fetch_next_user () =
      ignore (set_loading true);
      ignore (set_error_msg (Some ""));
      (* SIMULATED async - in real code this would be an async operation *)
      let next_id = if (Signal.get user_id) >= 5 then 1 else (Signal.get user_id) + 1 in
      schedule ~delay_ms:600 (fun () ->
        ignore (set_user_id next_id);
        ignore (set_loading false)
      )
    in

    (* Fetch specific user by ID *)
    let fetch_user_by_id_input id_str =
      ignore (set_loading true);
      ignore (set_error_msg (Some ""));
      (try
         let id = int_of_string id_str in
         schedule ~delay_ms:600 (fun () ->
           ignore (set_user_id id);
           ignore (set_loading false);
           if fetch_user_by_id ~id = None then
             ignore (set_error_msg (Some ("User not found: " ^ id_str)))
         )
       with
       | _ ->
         ignore (set_error_msg (Some "Invalid ID"));
         ignore (set_loading false))
    in

    <div class_="async-container resource-demo">
      <h2>(text "Reactive Resource State")</h2>
      <p class_="instructions">
        (text "This demonstrates reactive state management with loading, success, and error states. Enter a user ID (1-5) or use the buttons to load different users.")
      </p>

      (* Status Bar - reactive based on loading/error state *)
        (Tpl.show_when
          ~when_:(fun () -> Signal.get loading)
          (fun () ->
            <div class_="status-bar loading">
              <span class_="spinner"></span>
              (text "Loading user data...")
            </div>
          )
        )

        (Tpl.show_when
          ~when_:(fun () -> Signal.get loading)
          (fun () ->
            <div class_="skeleton-card">
              <div class_="skeleton-line skeleton-title"></div>
              <div class_="skeleton-line"></div>
              <div class_="skeleton-line"></div>
              <div class_="skeleton-line short"></div>
            </div>
          )
        )

      (* Error message display *)
      (Tpl.show_when
        ~when_:(fun () ->
          match Signal.get error_msg with
          | Some msg -> msg <> ""
          | None -> false)
        (fun () ->
          <div class_="status-bar error">
            (Tpl.text (fun () ->
              match Signal.get error_msg with
              | Some msg -> msg
              | None -> ""))
          </div>
        )
      )

      (* Success message when not loading and no error *)
      (Tpl.show_when
        ~when_:(fun () ->
          not (Signal.get loading) &&
          (match Signal.get error_msg with Some msg -> msg = "" | None -> true))
        (fun () ->
          <div class_="status-bar success">
            (text "User loaded successfully")
          </div>
        )
      )

      (* User Card - reactively displays current user *)
      (Tpl.show_when
        ~when_:(fun () ->
          not (Signal.get loading) &&
          (match Signal.get error_msg with Some msg -> msg = "" | None -> true) &&
          current_user () <> None)
        (fun () ->
          match current_user () with
          | Some user ->
              <div class_="user-card">
                <div class_="user-header">
                  <div class_="user-avatar">
                    (Tpl.text_once (fun () ->
                      let name = user.name in
                      if String.length name > 0 then
                        String.sub name 0 1 |> String.uppercase_ascii
                      else "?"))
                  </div>
                  <div>
                    <h2 class_="user-name">(Tpl.text_once (fun () -> user.name))</h2>
                    <p class_="user-email">(Tpl.text_once (fun () -> user.email))</p>
                  </div>
                </div>
                (match user.bio with
                 | Some bio ->
                     <div class_="user-bio">
                       <h3>(text "Bio")</h3>
                       <p>(Tpl.text_once (fun () -> bio))</p>
                     </div>
                 | None -> Html.text "")

                (* User controls *)
                <div class_="user-meta">
                  <span class_="user-id">
                    (Tpl.text_once (fun () -> "ID: " ^ string_of_int user.id))
                  </span>
                  <div class_="button-group">
                    <button
                      class_="btn btn-refresh"
                      onclick=(fun _ -> fetch_next_user ())>
                      (text "Next User")
                    </button>
                    <button
                      class_="btn btn-secondary"
                      onclick=(fun _ -> ignore (set_user_id 1); ignore (set_error_msg (Some "")))>
                      (text "Reset")
                    </button>
                  </div>
                </div>
              </div>
          | None -> Html.text ""
        )
      )

      (* Manual ID input section *)
      <div class_="section-divider"></div>
      <h3>(text "Fetch by ID")</h3>
      <div class_="form-group">
        <label for_="user-id-input">(text "User ID (1-5):")</label>
        <input
          id="user-id-input"
          type_="number"
          min="1"
          max="5"
          class_="search-input"
          value=(Tpl.bind_input
            ~signal:(fun () -> string_of_int (Signal.get user_id))
            ~setter:(fun s -> fetch_user_by_id_input s)
          )
        />
      </div>
    </div>

  (** {1 Sequential Requests Demo} *)

  let sequential_demo () =
    (* Reactive step state *)
    let step, set_step = Signal.create 0 in

    let steps_data = [
      ("Fetching user profile", "Loading user details...", "Success: User loaded");
      ("Loading user posts", "Fetching recent posts...", "Success: 5 posts found");
      ("Fetching comments", "Loading comments...", "Success: Comments loaded");
      ("All data loaded", "", "Complete!");
    ] in

    <div class_="async-container sequential-demo">
      <h2>(text "Step-by-Step State Transitions")</h2>
      <p class_="instructions">
        (text "This demonstrates state transitions with step tracking. Click 'Next Step' to advance through the stages.")
      </p>

      <div class_="steps-container">
        (Tpl.each_keyed
           ~items:(fun () ->
             let current_step = Signal.get step in
             List.mapi (fun idx (title, loading_msg, success_msg) ->
               let is_active = idx = current_step in
               let is_complete = idx < current_step in
               let step_class =
                 "step-item" ^
                 (if is_active then " active" else "") ^
                 (if is_complete then " complete" else "")
               in
               let status_class =
                 if is_active then "loading"
                 else if is_complete then "success"
                 else "pending"
               in
               let status_text =
                 if is_active then loading_msg
                 else if is_complete then success_msg
                 else "Pending"
               in
               let step_number = string_of_int (idx + 1) in
               { idx; title; step_class; status_class; status_text; step_number; is_complete }
             ) steps_data
           )
           ~key:(fun item -> string_of_int item.idx)
           ~render:(fun item ->
             <div class_=(fun () -> item.step_class)>
               <div class_="step-indicator">
                 (if item.is_complete then
                    <span class_="check">(text "OK")</span>
                  else
                    <span class_="step-number">(Tpl.text_once (fun () -> item.step_number))</span>)
               </div>
               <div class_="step-content">
                <h3>(Tpl.text_once (fun () -> item.title))</h3>
                <p class_=(fun () -> "step-status " ^ item.status_class)>(Tpl.text_once (fun () -> item.status_text))</p>
               </div>
             </div>
           )
        )
      </div>

      <div class_="demo-controls">
        <button
          class_="btn btn-primary"
          onclick=(fun _ ->
            let current_step = Signal.get step in
            if current_step < List.length steps_data then
              ignore (set_step (current_step + 1))
          )>
          (text "Next Step")
        </button>
        <button
          class_="btn btn-secondary"
          onclick=(fun _ -> ignore (set_step 0))>
          (text "Reset")
        </button>
      </div>
    </div>

  (** {1 Main View} *)

  let view ?(schedule=(fun ~delay_ms:_ f -> f ())) () : Html.node =
    let resource_node = resource_demo ~schedule () in
    <div>
      <h1>(text "Reactive State Management")</h1>
      <p class_="intro">
        (text "Examples of reactive state management with loading states, error handling, and derived computation.")
      </p>

      resource_node
    </div>
end
