(**
    Inline Edit Demo - Simple single-item edit flow.

    The example keeps one draft signal and allows editing one item at a time.
    - View mode shows static text and an Edit button
    - Edit mode shows an input with Save/Cancel
*)

type item = {
  id : int;
  text : string;
}

type view_item = {
  item : item;
  is_editing : bool;
}

module Make (Env : Solid_ml_template_runtime.Env_intf.TEMPLATE_ENV) = struct
  open Env
  module Html = Env.Html
  module Tpl = Env.Tpl
  module Routes = Routes

  open Html

  let view () =
    let initial_items = [
      { id = 1; text = "Learn solid-ml" };
      { id = 2; text = "Build reactive UIs" };
      { id = 3; text = "Master OCaml" };
      { id = 4; text = "Deploy to production" };
    ] in

    let items, set_items = Signal.create initial_items in
    let editing_id, set_editing_id = Signal.create None in
    let draft, set_draft = Signal.create "" in

    let start_edit item =
      set_editing_id (Some item.id);
      set_draft item.text
    in

    let cancel_edit () =
      set_editing_id None;
      set_draft ""
    in

    let save_edit () =
      match Signal.get editing_id with
      | None -> ()
      | Some id ->
        let next_text = Signal.get draft in
        set_items
          (List.map (fun item ->
             if item.id = id then { item with text = next_text } else item
           ) (Signal.get items));
        set_editing_id None;
        set_draft ""
    in

    let view_items () =
      let current_editing = Signal.get editing_id in
      Signal.get items
      |> List.map (fun item ->
        let is_editing =
          match current_editing with
          | Some id -> id = item.id
          | None -> false
        in
        { item; is_editing })
    in

    <div class_="inline-edit-container">
      <h1>(Html.text "Inline Edit Demo")</h1>

      <p class_="instructions">
        (Html.text "Edit one item at a time. Save applies changes; Cancel resets the draft.")
      </p>

      <ul class_="editable-list">
        (Tpl.each_keyed
           ~items:view_items
           ~key:(fun view_item -> Int.to_string view_item.item.id)
           ~render:(fun view_item ->
             let item = view_item.item in
             <li class_="editable-item">
               (if view_item.is_editing then
                   Html.fragment [
                     <input
                       type_="text"
                       class_="edit-input"
                       value=(Tpl.bind_input
                         ~signal:(fun () -> Signal.get draft)
                         ~setter:set_draft)
                     />;
                     <button class_="btn-save" onclick=(fun _ -> save_edit ())>
                       (Html.text "Save")
                     </button>;
                     <button class_="btn-cancel" onclick=(fun _ -> cancel_edit ())>
                       (Html.text "Cancel")
                     </button>;
                   ]
                 else
                   Html.fragment [
                     <span class_="item-text">(Tpl.text_once (fun () -> item.text))</span>;
                     <button class_="btn-edit" onclick=(fun _ -> start_edit item)>
                       (Html.text "Edit")
                     </button>;
                   ]
               )
             </li>
           )
        )
      </ul>

      <div class_="status-bar">
        (Html.text "Only one item can be edited at a time.")
      </div>
    </div>
end
